/*
AskNews API

AskNews API [![status](https://status.asknews.app/api/badge/2/status?style=for-the-badge)](https://status.asknews.app/status/prod)

API version: 0.24.27
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package asknews

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// StoriesAPIService StoriesAPI service
type StoriesAPIService service

type ApiGetStoriesRequest struct {
	ctx context.Context
	ApiService *StoriesAPIService
	query *string
	categories *[]string
	uuids *[]*string
	startTimestamp *int32
	endTimestamp *int32
	sortBy *string
	sortType *string
	continent *Continent
	offset *Offset1
	limit *int32
	expandUpdates *bool
	maxUpdates *int32
	maxArticles *int32
	method *string
	objType *[]string
	reddit *int32
	citationMethod *string
	similarityScoreThreshold *float32
	provocative *string
	strategy *string
}

// Query to be used for the search. If method&#x3D;&#39;nl&#39;, then this will beused as a natural language query. If method&#x3D;&#39;kw&#39;, then this willbe used as a direct keyword query.
func (r ApiGetStoriesRequest) Query(query string) ApiGetStoriesRequest {
	r.query = &query
	return r
}

// Categories to use for filtering the stories search
func (r ApiGetStoriesRequest) Categories(categories []string) ApiGetStoriesRequest {
	r.categories = &categories
	return r
}

// A list of UUIDs to retrieve.
func (r ApiGetStoriesRequest) Uuids(uuids []*string) ApiGetStoriesRequest {
	r.uuids = &uuids
	return r
}

// Start timestamp to filter results on.
func (r ApiGetStoriesRequest) StartTimestamp(startTimestamp int32) ApiGetStoriesRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// End timestamp to filter results on.
func (r ApiGetStoriesRequest) EndTimestamp(endTimestamp int32) ApiGetStoriesRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Which type of sorting to perform. published: Sort by published date. coverage: Sort by coverage. sentiment: Sort by sentiment. relevance: Sort by relevance of similarity score/ranking.
func (r ApiGetStoriesRequest) SortBy(sortBy string) ApiGetStoriesRequest {
	r.sortBy = &sortBy
	return r
}

// Whether to sort results in ascending or descending order.
func (r ApiGetStoriesRequest) SortType(sortType string) ApiGetStoriesRequest {
	r.sortType = &sortType
	return r
}

// Continents to filter by.
func (r ApiGetStoriesRequest) Continent(continent Continent) ApiGetStoriesRequest {
	r.continent = &continent
	return r
}

// Offset to use
func (r ApiGetStoriesRequest) Offset(offset Offset1) ApiGetStoriesRequest {
	r.offset = &offset
	return r
}

// Limit to use
func (r ApiGetStoriesRequest) Limit(limit int32) ApiGetStoriesRequest {
	r.limit = &limit
	return r
}

// Whether to expand updates
func (r ApiGetStoriesRequest) ExpandUpdates(expandUpdates bool) ApiGetStoriesRequest {
	r.expandUpdates = &expandUpdates
	return r
}

// Max updates to use
func (r ApiGetStoriesRequest) MaxUpdates(maxUpdates int32) ApiGetStoriesRequest {
	r.maxUpdates = &maxUpdates
	return r
}

// Max articles to use per update
func (r ApiGetStoriesRequest) MaxArticles(maxArticles int32) ApiGetStoriesRequest {
	r.maxArticles = &maxArticles
	return r
}

// Method to use for query, &#39;nl&#39; means natural language, and will run a semantic search on the stories database. &#39;kw&#39; means keyword, and will search by keyword on the stories database. &#39;both&#39; means that both methods will be used and results will be ranked according to IRR.
func (r ApiGetStoriesRequest) Method(method string) ApiGetStoriesRequest {
	r.method = &method
	return r
}

// Object type to filter by, can be a list with &#39;story&#39; and/or &#39;story_update&#39;
func (r ApiGetStoriesRequest) ObjType(objType []string) ApiGetStoriesRequest {
	r.objType = &objType
	return r
}

// Whether or not to include Reddit analysiswhere the integer indicates the number of threadsto include in the response. 0 is default. Requirespaid plan to access.
func (r ApiGetStoriesRequest) Reddit(reddit int32) ApiGetStoriesRequest {
	r.reddit = &reddit
	return r
}

// Method to use for citation filtering.
func (r ApiGetStoriesRequest) CitationMethod(citationMethod string) ApiGetStoriesRequest {
	r.citationMethod = &citationMethod
	return r
}

// Similarity score threshold to use when using query
func (r ApiGetStoriesRequest) SimilarityScoreThreshold(similarityScoreThreshold float32) ApiGetStoriesRequest {
	r.similarityScoreThreshold = &similarityScoreThreshold
	return r
}

// Filter stories based on how provocative the underlying articles are deemed based on the use of provocative language and emotional vocabulary.
func (r ApiGetStoriesRequest) Provocative(provocative string) ApiGetStoriesRequest {
	r.provocative = &provocative
	return r
}

// Strategy to use for automatically controlling the search. &#39;default&#39; is the default strategy, which follows all filters faithfully. &#39;topstories&#39; aims to give a diverse look at top news stories that are relevant to the current filter combination.&#39;topstories_categories&#39; aims to give the top stories for each category. &#39;topstories_continents&#39; aims to give the top stories for each continent.
func (r ApiGetStoriesRequest) Strategy(strategy string) ApiGetStoriesRequest {
	r.strategy = &strategy
	return r
}

func (r ApiGetStoriesRequest) Execute() (*StoriesResponse, *http.Response, error) {
	return r.ApiService.GetStoriesExecute(r)
}

/*
GetStories Filter and search for top news narratives

Filter on our custom, in-house written, stories/events/narratives.

These stories are based on clusters of articles (which come through this
endpoint as well, so you can consider this a clustering endpoint). We write
stories and track them through time.

The enrichments include a full Reddit overview (including all the thread metadata),
as well as descriptions of the reporting voice, the key takeaways, contradictions,
all the entities, and much, much more.

You can see this data in action, and filter it similarly at
`https://asknews.app/stories`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStoriesRequest
*/
func (a *StoriesAPIService) GetStories(ctx context.Context) ApiGetStoriesRequest {
	return ApiGetStoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StoriesResponse
func (a *StoriesAPIService) GetStoriesExecute(r ApiGetStoriesRequest) (*StoriesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StoriesAPIService.GetStories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/stories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "categories", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "categories", t, "form", "multi")
		}
	} else {
		var defaultValue []string = []string{}
		r.categories = &defaultValue
	}
	if r.uuids != nil {
		t := *r.uuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uuids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uuids", t, "form", "multi")
		}
	} else {
		var defaultValue []*string = []*string{}
		r.uuids = &defaultValue
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_timestamp", r.startTimestamp, "form", "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_timestamp", r.endTimestamp, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_type", r.sortType, "form", "")
	}
	if r.continent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continent", r.continent, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue Offset1
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.expandUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_updates", r.expandUpdates, "form", "")
	} else {
		var defaultValue bool = false
		r.expandUpdates = &defaultValue
	}
	if r.maxUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_updates", r.maxUpdates, "form", "")
	} else {
		var defaultValue int32 = 2
		r.maxUpdates = &defaultValue
	}
	if r.maxArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_articles", r.maxArticles, "form", "")
	} else {
		var defaultValue int32 = 5
		r.maxArticles = &defaultValue
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "form", "")
	} else {
		var defaultValue string = "kw"
		r.method = &defaultValue
	}
	if r.objType != nil {
		t := *r.objType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "obj_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "obj_type", t, "form", "multi")
		}
	} else {
		var defaultValue []string = []string{}
		r.objType = &defaultValue
	}
	if r.reddit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reddit", r.reddit, "form", "")
	} else {
		var defaultValue int32 = 0
		r.reddit = &defaultValue
	}
	if r.citationMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citation_method", r.citationMethod, "form", "")
	} else {
		var defaultValue string = "brackets"
		r.citationMethod = &defaultValue
	}
	if r.similarityScoreThreshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "similarity_score_threshold", r.similarityScoreThreshold, "form", "")
	} else {
		var defaultValue float32 = 0.75
		r.similarityScoreThreshold = &defaultValue
	}
	if r.provocative != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provocative", r.provocative, "form", "")
	} else {
		var defaultValue string = "all"
		r.provocative = &defaultValue
	}
	if r.strategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategy", r.strategy, "form", "")
	} else {
		var defaultValue string = "default"
		r.strategy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel41
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel42
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel43
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel44
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoryRequest struct {
	ctx context.Context
	ApiService *StoriesAPIService
	storyId string
	expandUpdates *bool
	maxUpdates *int32
	maxArticles *int32
	reddit *int32
	citationMethod *string
	condenseAuxillaryUpdates *bool
}

// Whether to expand updates
func (r ApiGetStoryRequest) ExpandUpdates(expandUpdates bool) ApiGetStoryRequest {
	r.expandUpdates = &expandUpdates
	return r
}

// Max number of updates to include in the story object
func (r ApiGetStoryRequest) MaxUpdates(maxUpdates int32) ApiGetStoryRequest {
	r.maxUpdates = &maxUpdates
	return r
}

// Max articles to include per update
func (r ApiGetStoryRequest) MaxArticles(maxArticles int32) ApiGetStoryRequest {
	r.maxArticles = &maxArticles
	return r
}

// Whether to include Reddit analysis
func (r ApiGetStoryRequest) Reddit(reddit int32) ApiGetStoryRequest {
	r.reddit = &reddit
	return r
}

// Method to use for citation filtering.
func (r ApiGetStoryRequest) CitationMethod(citationMethod string) ApiGetStoryRequest {
	r.citationMethod = &citationMethod
	return r
}

// When requesting a particular story update, you can expand the assocaited updates by settined max_updates to the total you would like to get. If you want those updates to by condensed for reduced latency, you can set  condense_auxillary_updates to &#39;False&#39;.
func (r ApiGetStoryRequest) CondenseAuxillaryUpdates(condenseAuxillaryUpdates bool) ApiGetStoryRequest {
	r.condenseAuxillaryUpdates = &condenseAuxillaryUpdates
	return r
}

func (r ApiGetStoryRequest) Execute() (*StoryResponse, *http.Response, error) {
	return r.ApiService.GetStoryExecute(r)
}

/*
GetStory Get a story containing updates

Get a single news story given its UUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storyId The story UUID, update UUID, or URL safe title
 @return ApiGetStoryRequest
*/
func (a *StoriesAPIService) GetStory(ctx context.Context, storyId string) ApiGetStoryRequest {
	return ApiGetStoryRequest{
		ApiService: a,
		ctx: ctx,
		storyId: storyId,
	}
}

// Execute executes the request
//  @return StoryResponse
func (a *StoriesAPIService) GetStoryExecute(r ApiGetStoryRequest) (*StoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StoriesAPIService.GetStory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/stories/{story_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"story_id"+"}", url.PathEscape(parameterValueToString(r.storyId, "storyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expandUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand_updates", r.expandUpdates, "form", "")
	} else {
		var defaultValue bool = true
		r.expandUpdates = &defaultValue
	}
	if r.maxUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_updates", r.maxUpdates, "form", "")
	} else {
		var defaultValue int32 = 10
		r.maxUpdates = &defaultValue
	}
	if r.maxArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_articles", r.maxArticles, "form", "")
	} else {
		var defaultValue int32 = 25
		r.maxArticles = &defaultValue
	}
	if r.reddit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reddit", r.reddit, "form", "")
	} else {
		var defaultValue int32 = 0
		r.reddit = &defaultValue
	}
	if r.citationMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citation_method", r.citationMethod, "form", "")
	} else {
		var defaultValue string = "brackets"
		r.citationMethod = &defaultValue
	}
	if r.condenseAuxillaryUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "condense_auxillary_updates", r.condenseAuxillaryUpdates, "form", "")
	} else {
		var defaultValue bool = true
		r.condenseAuxillaryUpdates = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel37
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel38
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel39
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel40
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
