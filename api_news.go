/*
AskNews API

AskNews API [![status](https://status.asknews.app/api/badge/2/status?style=for-the-badge)](https://status.asknews.app/status/prod)

API version: 0.24.22
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package asknews

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// NewsAPIService NewsAPI service
type NewsAPIService service

type ApiGetArticleRequest struct {
	ctx context.Context
	ApiService *NewsAPIService
	articleId string
}

func (r ApiGetArticleRequest) Execute() (*SearchResponseDictItem, *http.Response, error) {
	return r.ApiService.GetArticleExecute(r)
}

/*
GetArticle Get an article by its UUID

Get a single article given a UUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param articleId Article ID to retrieve
 @return ApiGetArticleRequest
*/
func (a *NewsAPIService) GetArticle(ctx context.Context, articleId string) ApiGetArticleRequest {
	return ApiGetArticleRequest{
		ApiService: a,
		ctx: ctx,
		articleId: articleId,
	}
}

// Execute executes the request
//  @return SearchResponseDictItem
func (a *NewsAPIService) GetArticleExecute(r ApiGetArticleRequest) (*SearchResponseDictItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResponseDictItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsAPIService.GetArticle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/news/{article_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"article_id"+"}", url.PathEscape(parameterValueToString(r.articleId, "articleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel17
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel18
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel19
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel20
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArticlesRequest struct {
	ctx context.Context
	ApiService *NewsAPIService
	articleIds *[]string
}

// Article UUIDs to fetch.
func (r ApiGetArticlesRequest) ArticleIds(articleIds []string) ApiGetArticlesRequest {
	r.articleIds = &articleIds
	return r
}

func (r ApiGetArticlesRequest) Execute() ([]SearchResponseDictItem, *http.Response, error) {
	return r.ApiService.GetArticlesExecute(r)
}

/*
GetArticles Get multiple articles by UUID

Get articles given a list of UUIDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArticlesRequest
*/
func (a *NewsAPIService) GetArticles(ctx context.Context) ApiGetArticlesRequest {
	return ApiGetArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SearchResponseDictItem
func (a *NewsAPIService) GetArticlesExecute(r ApiGetArticlesRequest) ([]SearchResponseDictItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchResponseDictItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsAPIService.GetArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/news"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.articleIds == nil {
		return localVarReturnValue, nil, reportError("articleIds is required and must be specified")
	}

	{
		t := *r.articleIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "article_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "article_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel14
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel15
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel16
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndexCountsRequest struct {
	ctx context.Context
	ApiService *NewsAPIService
	startDatetime *time.Time
	endDatetime *time.Time
	domains *[]string
	sampling *string
	timeFilter *string
	categories *[]string
	provocative *string
	reportingVoice *[]string
	badDomainUrl *BadDomainUrl1
	pageRank *int32
	stringGuarantee *[]string
	stringGuaranteeOp *string
	reverseStringGuarantee *[]string
	entityGuarantee *[]string
	entityGuaranteeOp *string
	languages *[]string
	countries *[]string
	countriesBlacklist *[]string
	continents *[]string
	sentiment *string
}

// Start timestamp to filter by
func (r ApiGetIndexCountsRequest) StartDatetime(startDatetime time.Time) ApiGetIndexCountsRequest {
	r.startDatetime = &startDatetime
	return r
}

// End timestamp to filter by
func (r ApiGetIndexCountsRequest) EndDatetime(endDatetime time.Time) ApiGetIndexCountsRequest {
	r.endDatetime = &endDatetime
	return r
}

// Domain or list of domains to get indexing counts for
func (r ApiGetIndexCountsRequest) Domains(domains []string) ApiGetIndexCountsRequest {
	r.domains = &domains
	return r
}

// Sampling to use
func (r ApiGetIndexCountsRequest) Sampling(sampling string) ApiGetIndexCountsRequest {
	r.sampling = &sampling
	return r
}

// Control which date type to filter on. &#39;crawl_date&#39; is the date the article was crawled, &#39;pub_date&#39; is the date the article was published.
func (r ApiGetIndexCountsRequest) TimeFilter(timeFilter string) ApiGetIndexCountsRequest {
	r.timeFilter = &timeFilter
	return r
}

// Categories of news to filter on
func (r ApiGetIndexCountsRequest) Categories(categories []string) ApiGetIndexCountsRequest {
	r.categories = &categories
	return r
}

// Filter articles based on how provocative they are deemed based on the use of provocative language and emotional vocabulary.
func (r ApiGetIndexCountsRequest) Provocative(provocative string) ApiGetIndexCountsRequest {
	r.provocative = &provocative
	return r
}

// Type of reporting voice to filer by.
func (r ApiGetIndexCountsRequest) ReportingVoice(reportingVoice []string) ApiGetIndexCountsRequest {
	r.reportingVoice = &reportingVoice
	return r
}

// blacklist of domains that must be excluded from resultsThis can be a single domain url or a list of domain urls.
func (r ApiGetIndexCountsRequest) BadDomainUrl(badDomainUrl BadDomainUrl1) ApiGetIndexCountsRequest {
	r.badDomainUrl = &badDomainUrl
	return r
}

// maximum allowed pagerank for returned articles
func (r ApiGetIndexCountsRequest) PageRank(pageRank int32) ApiGetIndexCountsRequest {
	r.pageRank = &pageRank
	return r
}

// If defined, the search will only occur on articles that contain this string.
func (r ApiGetIndexCountsRequest) StringGuarantee(stringGuarantee []string) ApiGetIndexCountsRequest {
	r.stringGuarantee = &stringGuarantee
	return r
}

// Operator to use for string guarantee.
func (r ApiGetIndexCountsRequest) StringGuaranteeOp(stringGuaranteeOp string) ApiGetIndexCountsRequest {
	r.stringGuaranteeOp = &stringGuaranteeOp
	return r
}

// If defined, the search will only occur on articles that do not contain this string.
func (r ApiGetIndexCountsRequest) ReverseStringGuarantee(reverseStringGuarantee []string) ApiGetIndexCountsRequest {
	r.reverseStringGuarantee = &reverseStringGuarantee
	return r
}

// Entity guarantee to filter by. This is a list of strings, where each string includes entity type and entity value separated by a colon. The first element is the entity type and the second element is the entity value. For example [&#39;Location:Paris&#39;, &#39;Person:John&#39;]
func (r ApiGetIndexCountsRequest) EntityGuarantee(entityGuarantee []string) ApiGetIndexCountsRequest {
	r.entityGuarantee = &entityGuarantee
	return r
}

// Operator to use for entity guarantee.
func (r ApiGetIndexCountsRequest) EntityGuaranteeOp(entityGuaranteeOp string) ApiGetIndexCountsRequest {
	r.entityGuaranteeOp = &entityGuaranteeOp
	return r
}

// Languages to filter by. This is the two-letter &#39;set 1&#39; of the ISO 639-1 standard. For example: English is &#39;en&#39;.
func (r ApiGetIndexCountsRequest) Languages(languages []string) ApiGetIndexCountsRequest {
	r.languages = &languages
	return r
}

// Source countries to filter by (this is only for the publisher location, not the locations mentioned in articles. For Locations mentioned in articles, refer to entity_guarantee), countries must be the two-letter ISO country codeFor example: United States is &#39;US&#39;, France is &#39;FR&#39;, Sweden is &#39;SE&#39;.
func (r ApiGetIndexCountsRequest) Countries(countries []string) ApiGetIndexCountsRequest {
	r.countries = &countries
	return r
}

// Source countries to blacklist from search (this is only for the publisher location, not the locations mentioned in articles. For Locations mentioned in articles, refer to reverse_entity_guarantee), countries must be the two-letter ISO country codeFor example: United States is &#39;US&#39;, France is &#39;FR&#39;, Sweden is &#39;SE&#39;.
func (r ApiGetIndexCountsRequest) CountriesBlacklist(countriesBlacklist []string) ApiGetIndexCountsRequest {
	r.countriesBlacklist = &countriesBlacklist
	return r
}

// Continents to filter by
func (r ApiGetIndexCountsRequest) Continents(continents []string) ApiGetIndexCountsRequest {
	r.continents = &continents
	return r
}

// Sentiment to filter news articles by.
func (r ApiGetIndexCountsRequest) Sentiment(sentiment string) ApiGetIndexCountsRequest {
	r.sentiment = &sentiment
	return r
}

func (r ApiGetIndexCountsRequest) Execute() ([]IndexCountItem, *http.Response, error) {
	return r.ApiService.GetIndexCountsExecute(r)
}

/*
GetIndexCounts Get the index counts underlying AskNews

This endpoint is primarly used for the publisher dashboard, to
show the number of articles indexed per source.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIndexCountsRequest
*/
func (a *NewsAPIService) GetIndexCounts(ctx context.Context) ApiGetIndexCountsRequest {
	return ApiGetIndexCountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IndexCountItem
func (a *NewsAPIService) GetIndexCountsExecute(r ApiGetIndexCountsRequest) ([]IndexCountItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IndexCountItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsAPIService.GetIndexCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/index_counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_datetime", r.startDatetime, "form", "")
	}
	if r.endDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_datetime", r.endDatetime, "form", "")
	}
	if r.domains != nil {
		t := *r.domains
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domains", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domains", t, "form", "multi")
		}
	}
	if r.sampling != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sampling", r.sampling, "form", "")
	} else {
		var defaultValue string = "1d"
		r.sampling = &defaultValue
	}
	if r.timeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_filter", r.timeFilter, "form", "")
	} else {
		var defaultValue string = "pub_date"
		r.timeFilter = &defaultValue
	}
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "categories", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "categories", t, "form", "multi")
		}
	}
	if r.provocative != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provocative", r.provocative, "form", "")
	}
	if r.reportingVoice != nil {
		t := *r.reportingVoice
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reporting_voice", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reporting_voice", t, "form", "multi")
		}
	}
	if r.badDomainUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bad_domain_url", r.badDomainUrl, "form", "")
	}
	if r.pageRank != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_rank", r.pageRank, "form", "")
	}
	if r.stringGuarantee != nil {
		t := *r.stringGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", t, "form", "multi")
		}
	}
	if r.stringGuaranteeOp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee_op", r.stringGuaranteeOp, "form", "")
	} else {
		var defaultValue string = "AND"
		r.stringGuaranteeOp = &defaultValue
	}
	if r.reverseStringGuarantee != nil {
		t := *r.reverseStringGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_string_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_string_guarantee", t, "form", "multi")
		}
	}
	if r.entityGuarantee != nil {
		t := *r.entityGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee", t, "form", "multi")
		}
	}
	if r.entityGuaranteeOp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee_op", r.entityGuaranteeOp, "form", "")
	} else {
		var defaultValue string = "OR"
		r.entityGuaranteeOp = &defaultValue
	}
	if r.languages != nil {
		t := *r.languages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "languages", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "languages", t, "form", "multi")
		}
	}
	if r.countries != nil {
		t := *r.countries
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countries", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countries", t, "form", "multi")
		}
	}
	if r.countriesBlacklist != nil {
		t := *r.countriesBlacklist
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countries_blacklist", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countries_blacklist", t, "form", "multi")
		}
	}
	if r.continents != nil {
		t := *r.continents
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "continents", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "continents", t, "form", "multi")
		}
	}
	if r.sentiment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sentiment", r.sentiment, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel25
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel26
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel27
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel28
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourcesReportRequest struct {
	ctx context.Context
	ApiService *NewsAPIService
	nPoints *int32
	startTimestamp *int32
	endTimestamp *int32
	metric *string
	sampling *string
}

// Number of points to return
func (r ApiGetSourcesReportRequest) NPoints(nPoints int32) ApiGetSourcesReportRequest {
	r.nPoints = &nPoints
	return r
}

// Start timestamp to filter by
func (r ApiGetSourcesReportRequest) StartTimestamp(startTimestamp int32) ApiGetSourcesReportRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// End timestamp to filter by
func (r ApiGetSourcesReportRequest) EndTimestamp(endTimestamp int32) ApiGetSourcesReportRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Metric to filter by
func (r ApiGetSourcesReportRequest) Metric(metric string) ApiGetSourcesReportRequest {
	r.metric = &metric
	return r
}

// Sampling to use
func (r ApiGetSourcesReportRequest) Sampling(sampling string) ApiGetSourcesReportRequest {
	r.sampling = &sampling
	return r
}

func (r ApiGetSourcesReportRequest) Execute() ([]SourceReportItem, *http.Response, error) {
	return r.ApiService.GetSourcesReportExecute(r)
}

/*
GetSourcesReport Get the sources underlying AskNews

This endpoint is primarly used for transparency and monitoring the
diversity of the data.

Visualized at `https://asknews.app/transparency`.

Get the distribution of sources/languages/countries underlying AskNews content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSourcesReportRequest
*/
func (a *NewsAPIService) GetSourcesReport(ctx context.Context) ApiGetSourcesReportRequest {
	return ApiGetSourcesReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SourceReportItem
func (a *NewsAPIService) GetSourcesReportExecute(r ApiGetSourcesReportRequest) ([]SourceReportItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SourceReportItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsAPIService.GetSourcesReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nPoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "n_points", r.nPoints, "form", "")
	} else {
		var defaultValue int32 = 100
		r.nPoints = &defaultValue
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_timestamp", r.startTimestamp, "form", "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_timestamp", r.endTimestamp, "form", "")
	}
	if r.metric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric", r.metric, "form", "")
	} else {
		var defaultValue string = "countries_diversity"
		r.metric = &defaultValue
	}
	if r.sampling != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sampling", r.sampling, "form", "")
	} else {
		var defaultValue string = "1h"
		r.sampling = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel21
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel22
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel23
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel24
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchNewsRequest struct {
	ctx context.Context
	ApiService *NewsAPIService
	query *string
	nArticles *int32
	startTimestamp *int32
	endTimestamp *int32
	timeFilter *string
	returnType *string
	historical *bool
	method *string
	similarityScoreThreshold *float32
	offset *Offset
	categories *[]string
	docStartDelimiter *string
	docEndDelimiter *string
	provocative *string
	reportingVoice *ReportingVoice
	domainUrl *DomainUrl
	badDomainUrl *BadDomainUrl
	pageRank *int32
	diversifySources *bool
	strategy *string
	hoursBack *int32
	stringGuarantee *[]string
	stringGuaranteeOp *string
	reverseStringGuarantee *[]string
	entityGuarantee *[]string
	reverseEntityGuarantee *[]string
	entityGuaranteeOp *string
	returnGraphs *bool
	returnGeo *bool
	languages *[]string
	countries *[]string
	countriesBlacklist *[]string
	continents *[]string
	sentiment *string
	premium *bool
	authors *[]string
}

// Query string that can be any phrase, keyword, question, or paragraph. If method&#x3D;&#39;nl&#39;, then this will be used as a natural language query. If method&#x3D;&#39;kw&#39;, then this will be used as a direct keyword query. This is not required, if it is not passed, then the search is based on the remaining filters only.
func (r ApiSearchNewsRequest) Query(query string) ApiSearchNewsRequest {
	r.query = &query
	return r
}

// Number of articles to return
func (r ApiSearchNewsRequest) NArticles(nArticles int32) ApiSearchNewsRequest {
	r.nArticles = &nArticles
	return r
}

// Timestamp to start search from
func (r ApiSearchNewsRequest) StartTimestamp(startTimestamp int32) ApiSearchNewsRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// Timestamp to end search at
func (r ApiSearchNewsRequest) EndTimestamp(endTimestamp int32) ApiSearchNewsRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Control which date type to filter on. &#39;crawl_date&#39; is the date the article was crawled, &#39;pub_date&#39; is the date the article was published.
func (r ApiSearchNewsRequest) TimeFilter(timeFilter string) ApiSearchNewsRequest {
	r.timeFilter = &timeFilter
	return r
}

// Type of return value. &#39;string&#39; means that the return is prompt-optimized and ready to be immediately injected into any prompt. &#39;dicts&#39; means that the return is a structured dictionary, containing additional metadata (like a classic news api). Can be &#39;string&#39; or &#39;dicts&#39;, or &#39;both&#39;. &#39;string&#39; guarantees the lowest-latency response &#39;dicts&#39; requires more I/O, therefore increases latency (very slightly, depending on your network connection).
func (r ApiSearchNewsRequest) ReturnType(returnType string) ApiSearchNewsRequest {
	r.returnType = &returnType
	return r
}

// Search on archive of historical news. Defaults to False, meaning that the search will only look through the most recent news (48 hours)
func (r ApiSearchNewsRequest) Historical(historical bool) ApiSearchNewsRequest {
	r.historical = &historical
	return r
}

// Method to use for searching. &#39;nl&#39; means Natural Language, which is a string that can be any phrase, keyword, question, or paragraph that will be used for semantic search on the news. &#39;kw&#39; means Keyword, which can also be any keyword(s), phrase, or paragraph, however the search is a direct keyword search on the database. &#39;both&#39; means both methods will be used and results will be ranked according to IRR. &#39;both&#39; may reduce latency by 10 pct in exchange  for improved accuracy.
func (r ApiSearchNewsRequest) Method(method string) ApiSearchNewsRequest {
	r.method = &method
	return r
}

// Similarity score threshold to determine which articles to return. Lower means less similar results  are allowed.
func (r ApiSearchNewsRequest) SimilarityScoreThreshold(similarityScoreThreshold float32) ApiSearchNewsRequest {
	r.similarityScoreThreshold = &similarityScoreThreshold
	return r
}

// Offset for pagination. The n_articles is your page size, while your offset is the number of articles to skip to get to your page of interest. For example, if you want to get page 3 for n_article page size of 10, you would set offset to 20.
func (r ApiSearchNewsRequest) Offset(offset Offset) ApiSearchNewsRequest {
	r.offset = &offset
	return r
}

// Categories of news to filter on
func (r ApiSearchNewsRequest) Categories(categories []string) ApiSearchNewsRequest {
	r.categories = &categories
	return r
}

// Document start delimiter for string return.
func (r ApiSearchNewsRequest) DocStartDelimiter(docStartDelimiter string) ApiSearchNewsRequest {
	r.docStartDelimiter = &docStartDelimiter
	return r
}

// Document end delimiter for string return.
func (r ApiSearchNewsRequest) DocEndDelimiter(docEndDelimiter string) ApiSearchNewsRequest {
	r.docEndDelimiter = &docEndDelimiter
	return r
}

// Filter articles based on how provocative they are deemed based on the use of provocative language and emotional vocabulary.
func (r ApiSearchNewsRequest) Provocative(provocative string) ApiSearchNewsRequest {
	r.provocative = &provocative
	return r
}

// Type of reporting voice to filer by.
func (r ApiSearchNewsRequest) ReportingVoice(reportingVoice ReportingVoice) ApiSearchNewsRequest {
	r.reportingVoice = &reportingVoice
	return r
}

// filter by domain url of interest. This can be a single domain or a list of domains. For example, &#39;npr.org&#39; or [&#39;nature.com&#39;, &#39;npr.org&#39;]
func (r ApiSearchNewsRequest) DomainUrl(domainUrl DomainUrl) ApiSearchNewsRequest {
	r.domainUrl = &domainUrl
	return r
}

// blacklist of domains that must be excluded from resultsThis can be a single domain url or a list of domain urls.
func (r ApiSearchNewsRequest) BadDomainUrl(badDomainUrl BadDomainUrl) ApiSearchNewsRequest {
	r.badDomainUrl = &badDomainUrl
	return r
}

// Maximum allowed page rank for returned articles.
func (r ApiSearchNewsRequest) PageRank(pageRank int32) ApiSearchNewsRequest {
	r.pageRank = &pageRank
	return r
}

// Ensure that the return set of articles are selected from diverse sources. This adds latency to the search, but attempts to balance the representation of sources by country and source origins. In summary, a net is cast around your search, then the diversity of sources is analyzed, and your final result matches the large net diversity distribution. This means that your search accuracy is reduced, but you gain more diverse perspectives.
func (r ApiSearchNewsRequest) DiversifySources(diversifySources bool) ApiSearchNewsRequest {
	r.diversifySources = &diversifySources
	return r
}

// Strategy to use for searching. &#39;latest news&#39; automatically setsmethod&#x3D;&#39;nl&#39;, historical&#x3D;False, and looks within the past 24 hours. &#39;news knowledge&#39; automatically sets method&#x3D;&#39;kw&#39;, historical&#x3D;True, and looks within the past 60 days. &#39;news knowledge&#39; will increase latency due to the  larger search space in the archive. Use &#39;default&#39; if you want to control  start_timestamp, end_timestamp, historical, and method.
func (r ApiSearchNewsRequest) Strategy(strategy string) ApiSearchNewsRequest {
	r.strategy = &strategy
	return r
}

// Can be set to easily control the look back on the search. This is the same as controlling the &#39;start_timestamp&#39; parameter. The difference is that this is not a timestamp, it is the number of hours back to look from the current time. Defaults to 24 hours.
func (r ApiSearchNewsRequest) HoursBack(hoursBack int32) ApiSearchNewsRequest {
	r.hoursBack = &hoursBack
	return r
}

// If defined, the search will only occur on articles that contain strings in this list.
func (r ApiSearchNewsRequest) StringGuarantee(stringGuarantee []string) ApiSearchNewsRequest {
	r.stringGuarantee = &stringGuarantee
	return r
}

// Operator to use for string guarantee list.
func (r ApiSearchNewsRequest) StringGuaranteeOp(stringGuaranteeOp string) ApiSearchNewsRequest {
	r.stringGuaranteeOp = &stringGuaranteeOp
	return r
}

// If defined, the search will only occur on articles that do not contain strings in this list.
func (r ApiSearchNewsRequest) ReverseStringGuarantee(reverseStringGuarantee []string) ApiSearchNewsRequest {
	r.reverseStringGuarantee = &reverseStringGuarantee
	return r
}

// Entity guarantee to filter by. This is a list of strings, where each string includes entity type and entity value separated by a colon. The first element is the entity type and the second element is the entity value. For example [&#39;Location:Paris&#39;, &#39;Person:John&#39;]
func (r ApiSearchNewsRequest) EntityGuarantee(entityGuarantee []string) ApiSearchNewsRequest {
	r.entityGuarantee = &entityGuarantee
	return r
}

// Reverse entity guarantee to filter by. This is a list of strings, where each string includes entity type and entity value separated by a colon. The first element is the entity type and the second element is the entity value. For example [&#39;Location:Paris&#39;, &#39;Person:John&#39;]
func (r ApiSearchNewsRequest) ReverseEntityGuarantee(reverseEntityGuarantee []string) ApiSearchNewsRequest {
	r.reverseEntityGuarantee = &reverseEntityGuarantee
	return r
}

// Operator to use for entity guarantee list.
func (r ApiSearchNewsRequest) EntityGuaranteeOp(entityGuaranteeOp string) ApiSearchNewsRequest {
	r.entityGuaranteeOp = &entityGuaranteeOp
	return r
}

// Return graphs for the articles. Only available to Analyst tier and above.
func (r ApiSearchNewsRequest) ReturnGraphs(returnGraphs bool) ApiSearchNewsRequest {
	r.returnGraphs = &returnGraphs
	return r
}

// Return GeoCoordinates associated with locations discussed  inside the articles. Only available to Analyst tier and above.
func (r ApiSearchNewsRequest) ReturnGeo(returnGeo bool) ApiSearchNewsRequest {
	r.returnGeo = &returnGeo
	return r
}

// Languages to filter by. This is the two-letter &#39;set 1&#39; of the ISO 639-1 standard. For example: English is &#39;en&#39;.
func (r ApiSearchNewsRequest) Languages(languages []string) ApiSearchNewsRequest {
	r.languages = &languages
	return r
}

// Source countries to filter by (this is only for the publisher location, not the locations mentioned in articles. For Locations mentioned in articles, refer to entity_guarantee), countries must be the two-letter ISO country codeFor example: United States is &#39;US&#39;, France is &#39;FR&#39;, Sweden is &#39;SE&#39;.
func (r ApiSearchNewsRequest) Countries(countries []string) ApiSearchNewsRequest {
	r.countries = &countries
	return r
}

// Source countries to blacklist from search (this is only for the publisher location, not the locations mentioned in articles. For Locations mentioned in articles, refer to reverse_entity_guarantee), countries must be the two-letter ISO country codeFor example: United States is &#39;US&#39;, France is &#39;FR&#39;, Sweden is &#39;SE&#39;.
func (r ApiSearchNewsRequest) CountriesBlacklist(countriesBlacklist []string) ApiSearchNewsRequest {
	r.countriesBlacklist = &countriesBlacklist
	return r
}

// Continents to filter by.
func (r ApiSearchNewsRequest) Continents(continents []string) ApiSearchNewsRequest {
	r.continents = &continents
	return r
}

// Sentiment to filter articles by.
func (r ApiSearchNewsRequest) Sentiment(sentiment string) ApiSearchNewsRequest {
	r.sentiment = &sentiment
	return r
}

// Include premium sources.
func (r ApiSearchNewsRequest) Premium(premium bool) ApiSearchNewsRequest {
	r.premium = &premium
	return r
}

// Authors to filter articles by.
func (r ApiSearchNewsRequest) Authors(authors []string) ApiSearchNewsRequest {
	r.authors = &authors
	return r
}

func (r ApiSearchNewsRequest) Execute() (*SearchResponse, *http.Response, error) {
	return r.ApiService.SearchNewsExecute(r)
}

/*
SearchNews Search for enriched real-time news context

Search for any news, up to the last 5 minutes or in our extensive historical archive
filled with 100s of millions of articles.

Geared toward low-latency applications, where time is of the essence. For example, this
endpoint is commonly used for quickly getting news context for an LLM.

This endpoint is also commonly used for synthetic data curation. For example, say you
are fine-tuning a model for sports. You could filter  with `classification="Sports"`
and build a dataset of sports articles.

News articles come with an abundance of valuable metadata, including full summaries, sentiment,
entities, reporting voice, page rank, language, and much much more.

An example of this data in action can be found and interacted with at `https://asknews.app/chat`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchNewsRequest
*/
func (a *NewsAPIService) SearchNews(ctx context.Context) ApiSearchNewsRequest {
	return ApiSearchNewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResponse
func (a *NewsAPIService) SearchNewsExecute(r ApiSearchNewsRequest) (*SearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsAPIService.SearchNews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/news/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	} else {
		var defaultValue string = ""
		r.query = &defaultValue
	}
	if r.nArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "n_articles", r.nArticles, "form", "")
	} else {
		var defaultValue int32 = 10
		r.nArticles = &defaultValue
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_timestamp", r.startTimestamp, "form", "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_timestamp", r.endTimestamp, "form", "")
	}
	if r.timeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_filter", r.timeFilter, "form", "")
	} else {
		var defaultValue string = "crawl_date"
		r.timeFilter = &defaultValue
	}
	if r.returnType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_type", r.returnType, "form", "")
	} else {
		var defaultValue string = "dicts"
		r.returnType = &defaultValue
	}
	if r.historical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "historical", r.historical, "form", "")
	} else {
		var defaultValue bool = false
		r.historical = &defaultValue
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "form", "")
	} else {
		var defaultValue string = "kw"
		r.method = &defaultValue
	}
	if r.similarityScoreThreshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "similarity_score_threshold", r.similarityScoreThreshold, "form", "")
	} else {
		var defaultValue float32 = 0.5
		r.similarityScoreThreshold = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue Offset
		r.offset = &defaultValue
	}
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "categories", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "categories", t, "form", "multi")
		}
	}
	if r.docStartDelimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "doc_start_delimiter", r.docStartDelimiter, "form", "")
	} else {
		var defaultValue string = "<doc>"
		r.docStartDelimiter = &defaultValue
	}
	if r.docEndDelimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "doc_end_delimiter", r.docEndDelimiter, "form", "")
	} else {
		var defaultValue string = "</doc>"
		r.docEndDelimiter = &defaultValue
	}
	if r.provocative != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provocative", r.provocative, "form", "")
	}
	if r.reportingVoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporting_voice", r.reportingVoice, "form", "")
	}
	if r.domainUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain_url", r.domainUrl, "form", "")
	}
	if r.badDomainUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bad_domain_url", r.badDomainUrl, "form", "")
	}
	if r.pageRank != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_rank", r.pageRank, "form", "")
	}
	if r.diversifySources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "diversify_sources", r.diversifySources, "form", "")
	} else {
		var defaultValue bool = false
		r.diversifySources = &defaultValue
	}
	if r.strategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategy", r.strategy, "form", "")
	} else {
		var defaultValue string = "default"
		r.strategy = &defaultValue
	}
	if r.hoursBack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hours_back", r.hoursBack, "form", "")
	} else {
		var defaultValue int32 = 24
		r.hoursBack = &defaultValue
	}
	if r.stringGuarantee != nil {
		t := *r.stringGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", t, "form", "multi")
		}
	}
	if r.stringGuaranteeOp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee_op", r.stringGuaranteeOp, "form", "")
	} else {
		var defaultValue string = "AND"
		r.stringGuaranteeOp = &defaultValue
	}
	if r.reverseStringGuarantee != nil {
		t := *r.reverseStringGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_string_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_string_guarantee", t, "form", "multi")
		}
	}
	if r.entityGuarantee != nil {
		t := *r.entityGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee", t, "form", "multi")
		}
	}
	if r.reverseEntityGuarantee != nil {
		t := *r.reverseEntityGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_entity_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reverse_entity_guarantee", t, "form", "multi")
		}
	}
	if r.entityGuaranteeOp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entity_guarantee_op", r.entityGuaranteeOp, "form", "")
	} else {
		var defaultValue string = "OR"
		r.entityGuaranteeOp = &defaultValue
	}
	if r.returnGraphs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_graphs", r.returnGraphs, "form", "")
	} else {
		var defaultValue bool = false
		r.returnGraphs = &defaultValue
	}
	if r.returnGeo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_geo", r.returnGeo, "form", "")
	} else {
		var defaultValue bool = false
		r.returnGeo = &defaultValue
	}
	if r.languages != nil {
		t := *r.languages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "languages", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "languages", t, "form", "multi")
		}
	}
	if r.countries != nil {
		t := *r.countries
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countries", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countries", t, "form", "multi")
		}
	}
	if r.countriesBlacklist != nil {
		t := *r.countriesBlacklist
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countries_blacklist", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countries_blacklist", t, "form", "multi")
		}
	}
	if r.continents != nil {
		t := *r.continents
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "continents", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "continents", t, "form", "multi")
		}
	}
	if r.sentiment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sentiment", r.sentiment, "form", "")
	}
	if r.premium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "premium", r.premium, "form", "")
	} else {
		var defaultValue bool = false
		r.premium = &defaultValue
	}
	if r.authors != nil {
		t := *r.authors
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authors", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authors", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = "Bearer " + apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel3
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel4
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
