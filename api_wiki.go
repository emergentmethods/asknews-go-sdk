/*
AskNews API

AskNews API [![status](https://status.asknews.app/api/badge/2/status?style=for-the-badge)](https://status.asknews.app/status/prod)

API version: 0.24.27
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package asknews

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// WikiAPIService WikiAPI service
type WikiAPIService service

type ApiSearchWikiRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	query *string
	neighborChunks *int32
	nDocuments *int32
	fullArticles *bool
	hybridSearch *bool
	stringGuarantee *[]string
	diversify *float32
	includeMainSection *bool
}

// Natural language query that can be any phrase, keyword, question, or paragraph. 
func (r ApiSearchWikiRequest) Query(query string) ApiSearchWikiRequest {
	r.query = &query
	return r
}

// Number of neighbor chunks to attach and return. If 0, then no neighbor chunks will be returned. 
func (r ApiSearchWikiRequest) NeighborChunks(neighborChunks int32) ApiSearchWikiRequest {
	r.neighborChunks = &neighborChunks
	return r
}

// Number of documents to return. If 0, then no documents will be returned. 
func (r ApiSearchWikiRequest) NDocuments(nDocuments int32) ApiSearchWikiRequest {
	r.nDocuments = &nDocuments
	return r
}

// If true, then full articles will be returned. If false, then only chunks and their neighbors will be returned. Beware that returning full articles increases data size which increases token usage downstream.
func (r ApiSearchWikiRequest) FullArticles(fullArticles bool) ApiSearchWikiRequest {
	r.fullArticles = &fullArticles
	return r
}

// If true, then hybrid search will be used. If false, then only vector search will be used. 
func (r ApiSearchWikiRequest) HybridSearch(hybridSearch bool) ApiSearchWikiRequest {
	r.hybridSearch = &hybridSearch
	return r
}

// List of strings that must be present in the results. If empty, then no string guarantee will be applied. 
func (r ApiSearchWikiRequest) StringGuarantee(stringGuarantee []string) ApiSearchWikiRequest {
	r.stringGuarantee = &stringGuarantee
	return r
}

// Diversity factor for MMR re-ranking. 0.0 means no diversity (pure relevance), 1.0 means full diversity. 
func (r ApiSearchWikiRequest) Diversify(diversify float32) ApiSearchWikiRequest {
	r.diversify = &diversify
	return r
}

// If true, then the main section of the article will be included at the start of each chunk&#39;s content. If false, then only the chunk content will be returned. Useful because the main section often contains important context. 
func (r ApiSearchWikiRequest) IncludeMainSection(includeMainSection bool) ApiSearchWikiRequest {
	r.includeMainSection = &includeMainSection
	return r
}

func (r ApiSearchWikiRequest) Execute() (*WikiSearchResponse, *http.Response, error) {
	return r.ApiService.SearchWikiExecute(r)
}

/*
SearchWiki Search for Wikipedia context with natural language

Search on Wikipedia content with natural language. Find exactly relevant chunks,
with contextual neighbor chunks, and the full articles they came from.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchWikiRequest
*/
func (a *WikiAPIService) SearchWiki(ctx context.Context) ApiSearchWikiRequest {
	return ApiSearchWikiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WikiSearchResponse
func (a *WikiAPIService) SearchWikiExecute(r ApiSearchWikiRequest) (*WikiSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WikiSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.SearchWiki")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/wiki/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	} else {
		var defaultValue string = ""
		r.query = &defaultValue
	}
	if r.neighborChunks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_chunks", r.neighborChunks, "form", "")
	}
	if r.nDocuments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "n_documents", r.nDocuments, "form", "")
	}
	if r.fullArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_articles", r.fullArticles, "form", "")
	}
	if r.hybridSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hybrid_search", r.hybridSearch, "form", "")
	}
	if r.stringGuarantee != nil {
		t := *r.stringGuarantee
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "string_guarantee", t, "form", "multi")
		}
	}
	if r.diversify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "diversify", r.diversify, "form", "")
	}
	if r.includeMainSection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_main_section", r.includeMainSection, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v AbcAPIErrorModel93
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AbcAPIErrorModel94
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AbcAPIErrorModel95
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AbcAPIErrorModel96
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AsknewsApiErrorsAPIErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
